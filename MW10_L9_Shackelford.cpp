// Author:                      Jade Shackelford
// Assignment Number:           Lab 9
// File Name:                   MW10_L9_Shackelford.cpp
// Course/Section:              COSC 1337 Section xx
// Due Date:                    4/20
// Instructor:                  Thayer

/*
Lab Ch09
  To find places to add code, search on "<add code>"
  To find places to change code, search on "<change code>"
  To find either places, search on "code>"
*/

#include <iostream>
#include <iomanip>
#include <random> // needed for Orwell devcpp

using namespace std;

const int TARGET = 123456789;
// TARGET cannot be found. It is larger than any random number
// generated by rand(), as desired to test for worst-case performance.

// array helper functions:
void showArray(int array[], int size, const string &msg="") { // displays every element in array
  cout<<msg;
  for (int i{}; i<size; ++i)
    cout << setw(2) << array[i]; // assumes small numbers
  cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
  // returns true if array is in ascending order, else false.
  for (int i=0; i<(size-1); ++i)
    if (array[i]>array[i+1]) return false;
  return true;
}

// Each selection sort below does the same algorithm. The
// difference is in how well it documents its operation.
void selectionSortConcise(int[], int);   // from internet, not called
void selectionSortTextBook(int[], int);  // from our textbook, not called
void selectionSort(int[], int, bool);    // as expected for this lab

void bubbleSort(int[], int, bool);    
void insertionSort(int[], int, bool);    // expected for this lab <change code>

bool linearSearchArray(int [], int, int, int&); // provided
bool binarySearchArray(int [], int, int, int&); 

const int testSizes[] = {1000, 5000, 10000, 20000, 30000, 40000, 50000, 0};

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm(void sortAlgorithm(int [], int, bool),
                        int array[], int arraySize, bool verbose=false) {
  // This function is interesting. The first parameter is a "function pointer",
  // It accepts any function that returns a void and has parameters of type: (int [], int, bool)
  // The first parameter (in the caller) can be the name of a function being tested.
  // This reduces redundant code. The same sequence of tests are performed on each
  // sort function. (Our textbook does not mention function pointers.)
  
  // fill array with random, unsorted numbers to be sorted
  for (int index = 0; index < arraySize; index++)
    array[index] = rand();  // initialize array with random values
  int startTime = clock();  // get the start time, in milliseconds
  sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
  int stopTime = clock();   // get the stop time, in milliseconds
  float duration = stopTime - startTime;
  if (!verifySorted(array, arraySize))
    duration=-duration; // return a negative duration to indicate sort failure
  return duration;
}

// Copy/paste/modify/reuse this code as desired to test search algorithms.
float testLinearSearch(int array[], int arraySize, int retry=1000) {
  bool found = false; // true if TARGET is found in array
  int foundAt = 0;    // index in array where TARGET was found
  int startTime = clock();
  for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
    found = linearSearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
  int stopTime = clock();
  float duration = stopTime - startTime;
  return duration/retry; // divide duration by 1000 to get time for single search
}

// <add code> to test binary search. It works like testLinearSearch
float testBinarySearch(int array[], int arraySize, int retry=1000) {
  bool found = false; // true if TARGET is found in array
  int foundAt = 0;    // index in array where TARGET was found
  int startTime = clock();
  for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
	found = binarySearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
  int stopTime = clock();
  float duration = stopTime - startTime;
  return duration/retry;
}

void testAlgorithms(int array[], int arraySize, bool verbose=false) {
  // This draws a table of results for each algorithm tested.
  const int AlgorithmNameWidth=16;
  const int TestSizeWidth=10;
  const int DurationWidth=TestSizeWidth;
  cout << setw (AlgorithmNameWidth) << left << "Algorithm";
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(TestSizeWidth) << right << testSizes[testCount];
  cout << endl << string(AlgorithmNameWidth, '=');
  for (int testCount=0; testSizes[testCount]; ++testCount)
    cout << setw(DurationWidth) << right << " =======";
    
// Copy and/or reuse this code as desired to test your algorithms.
  cout << endl << setw (AlgorithmNameWidth) << left << "selection sort";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testSortAlgorithm(selectionSort, array, testSizes[testCount]);
    // In the line above, I am passing the name of the function selectionSort as a parameter into
    // the function testSortAlgorithm. You can do the same thing for your sort algorithms, as long
    // as your sort algorithms return a void and have parameters: (int array[], int size).
  
  // loop to call and test your first sort algorithm. <change code> rename my sort 1
  cout << endl << setw (AlgorithmNameWidth) << left << "bubble sort";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testSortAlgorithm(bubbleSort, array, testSizes[testCount]);
  
  // loop to call and test your second sort algorithm. <change code> rename my sort 2
  cout << endl << setw (AlgorithmNameWidth) << left << "insertion sort";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testSortAlgorithm(insertionSort, array, testSizes[testCount]);

  // Here, the provided linear search is tested...
  cout << endl << setw (AlgorithmNameWidth) << left << "linear search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

  // <change code> Use a loop to call and test your search algorithm here
  int bigArrayCopy[arraySize] {};
  for (int i = 0; i<arraySize; ++i) bigArrayCopy[i] = array[i];
  insertionSort(bigArrayCopy, arraySize, false);
  cout << endl << setw (AlgorithmNameWidth) << left << "binary search";
  for (int testCount=0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
    cout << setw(DurationWidth) << right << testBinarySearch(bigArrayCopy, testSizes[testCount]);
  cout << endl;
}


int main () {
  srand(time(0));  // seed the random number generator only once.

  // When first implementing your algorithm, test it on a very small array.
  const int defaultsmallArray[] = {5, 7, 2, 8, 9, 1}; // for testing purposes
  const int SMALLSIZE = sizeof(defaultsmallArray)/sizeof(defaultsmallArray[0]);
  int smallArray[SMALLSIZE] {}; // for testing purposes, resort several times
 
  cout << "Test sorting algorithms on small array:\n\n";
  for (int i{}; i<SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
  showArray(smallArray, SMALLSIZE, "Selection sort start: smallArray is: ");
  selectionSort(smallArray, SMALLSIZE, true); // true means to show details
  showArray(smallArray, SMALLSIZE, "Selection sort stop:  smallArray is: ");
  cout << ((verifySorted(smallArray, SMALLSIZE)) ?
    "verified: smallArray is sorted.\n" :
    "Ooops!!!: smallArray is NOT sorted.\n");

  // When first implementing your algorithm, test it
  // on a very small array. Test your new sorts on smallArray below.
  for (int i{}; i<SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
  showArray(smallArray, SMALLSIZE, "\nBubble sort start: smallArray is: ");
  bubbleSort(smallArray, SMALLSIZE, true); // true means to show details
  showArray(smallArray, SMALLSIZE, "Bubble sort stop:  smallArray is: ");
  cout << ((verifySorted(smallArray, SMALLSIZE)) ?
    "verified: smallArray is sorted.\n" :
    "Ooops!!!: smallArray is NOT sorted.\n");

  for (int i{}; i<SMALLSIZE; ++i) smallArray[i] = defaultsmallArray[i]; // initialize smallArray
  showArray(smallArray, SMALLSIZE, "\nInsertion sort start: smallArray is: ");
  insertionSort(smallArray, SMALLSIZE, true); // true means to show details
  showArray(smallArray, SMALLSIZE, "Insertion sort stop:  smallArray is: ");
  cout << ((verifySorted(smallArray, SMALLSIZE)) ?
    "verified: smallArray is sorted.\n" :
    "Ooops!!!: smallArray is NOT sorted.\n");

  const int BIGSIZE = 50000;
  int bigArray[BIGSIZE];
  float duration = 0.0; // time in milliseconds

  // Startup code performs a single test run using the full size of bigArray
  duration = testSortAlgorithm(selectionSort, bigArray, BIGSIZE);
  cout << fixed << setprecision(2);
  cout << "\nSelection sort on bigArray took: "
       << setw(7) << duration << " milliseconds." << endl;
       
  duration = testSortAlgorithm(bubbleSort, bigArray, BIGSIZE);
  cout << fixed << setprecision(2);
  cout << "\nBubble sort on bigArray took: "
       << setw(7) << duration << " milliseconds." << endl;
       
  duration = testSortAlgorithm(insertionSort, bigArray, BIGSIZE);
  cout << fixed << setprecision(2);
  cout << "\nInsertion sort on bigArray took: "
       << setw(7) << duration << " milliseconds." << endl;

  duration = testLinearSearch(bigArray, BIGSIZE);
  cout << "\nLinear search  of bigArray took: "
       << setw(7) << duration << " milliseconds.\n\n";

  int bigArrayCopy[BIGSIZE] {};
  for (int i = 0; i<BIGSIZE; ++i) bigArrayCopy[i] = bigArray[i];
  insertionSort(bigArrayCopy, BIGSIZE, false);
  duration = testBinarySearch(bigArrayCopy, BIGSIZE);
  cout << "Binary search  of bigArray took: "
       << setw(7) << duration << " milliseconds.\n\n";  

  // Test the algorithms on many ever longer list of numbers. Only one
  // array is needed.  Lengths of 1000, 5000, 10000, 20000, 30000,
  // 40000, 50000 are tested.
  testAlgorithms(bigArray, BIGSIZE);
  cout << endl;

  return 0;
} // end of main

// Your new search algorithm cannot be linear search, which is provided here.
bool linearSearchArray(int array[], int size, int target, int &position) {
  for (int i = 0; i < size; ++i)
    if (array[i] == target) // found it!
      {position=i; return true;}
  position = -1;
  return false;
}

bool binarySearchArray(int array[], int size, int target, int &position ) {
  //this sets up the bounds that will be used for the binary search
  int first = 0;
  //since the size of an array is set with values higher than 1 but called
  //with values higher than 0, this ensures the search wont try to access
  //an array location larger than what the array actually contains
  int last = size - 1;
  //this will be used to test if the search has found the target
  int search;
  //loop for search
  while (first <= last){
  	//sets what the middle value in the range of values within the array that could
  	//contain the target value
  	search = (first + last)/2;
  	//first check if middle value is correct
  	if (array[search] == target) {
  		//sets postion to the location the target was found at
  		position = search;
  		//returns that the sort was successfully able to locate the target
  		return true;
	}//then test if middle value is larger than target
	else if (array[search] > target) {
		//since the middle we found was larger, that means all values between
		//the middle and the ending value can't be the target so this removes
		//them from the search
		last = search - 1;
	}
	//since we've already tested == and > then this else tests if the middle
	//value is < the target
	else {
		//same as in the > test, this removes all values smaller than the middle
		//since they also cant be the target
		first = search + 1;
	}
  //if the target is not found, determined by if the last variable is set to a
  //value less than first, or the first variable being set to a value larger than
  //last, then the sort was unable to locate the target and returns false
  }
  //position is set so there is a value set to the constant that shows a position
  //was not found
  position = -1;
  return false;
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selectionSortConcise(int array[], int size) {
  int i, idx, val;
  for (i = 0; i < (size - 1); i++) {
    idx = i;
    val = array[i];
    for (int j = i + 1; j < size; j++) {
      if (array[j] < val) {
        val = array[j];
        idx = j;
      }
    }
    array[idx] = array[i];
    array[i] = val;
  }
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selectionSortTextbook(int array[], int size) {
  int startScan, minIndex, minValue;
  for (startScan = 0; startScan < (size - 1); startScan++) {
    minIndex = startScan;
    minValue = array[startScan];
    for (int index = startScan + 1; index < size; index++) {
      if (array[index] < minValue) {
        minValue = array[index];
        minIndex = index;
      }
    }
    array[minIndex] = array[startScan];
    array[startScan] = minValue;
  }
}

// This selection sort is described in great detail, as you should do for this lab
// As an option, it displays details of its operation for each pass.
void selectionSort(int array[], int size, bool verbose=false) {
  int minIndexSoFar = 0, minValueSoFar{array[0]};
  for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
    // The outer loop looks at unsorted data, which is initially the whole array.
    // Gradually, a smaller and smaller portion of the array remains unsorted.
    minIndexSoFar = unsortedIndex;
    minValueSoFar = array[unsortedIndex];
    for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
      // the inner loop seeks the smallest value possible in the
      // remaining unsorted portion of the array.
      if (array[seekMinIndex] < minValueSoFar) {
        // found a smaller value than I had before, save it for now
        if (verbose)
          cout << "  prev min value: " << minValueSoFar << " at offset: " << minIndexSoFar;
        minValueSoFar = array[seekMinIndex];
        minIndexSoFar = seekMinIndex;
        if (verbose)
          cout << "; yet smaller value: " << minValueSoFar << " at offset: " << minIndexSoFar << endl;
      }
    }
    // The smallest value in the unsorted portion of the array has been found.
    // Replace the older minimum value, which wasn't really the actual minimum
    // value, with the new, real minimum value which was just found.
    array[minIndexSoFar] = array[unsortedIndex];
    array[unsortedIndex] = minValueSoFar;
    if (verbose) {
      cout << "  swap prev min value: " << array[minIndexSoFar]
           << " with new min value: " << array[unsortedIndex] << endl;
      cout << "After pass " << unsortedIndex << " the array is: ";
      showArray(array, size);
      cout << endl;
    }

    // ... continue seeking the minimum value in the smaller remaining portion.
  }
}

void bubbleSort(int array[], int size, bool verbose=false) {
	//tempHold used to swap values of two array locations
	//counter keeps track of how many passes have occured
	int tempHold, counter = 0;
	//used to check if a swap occured, loops the sort if swaps occured to see if
	//any further swaps are needed. Loop ends when no swaps happen
	bool swapOccured = true;
	while (swapOccured){
		//this sets the default value for the loop check so if no swap happens
		//the loop ends
		swapOccured = false;
		//this compares values in an array to the values after them.
		//these comparisons are used to check if the array is in increasing order
		for (int count = 0; count < size - 1; count++){
			//if values in the array are not in increasing order, this swaps the values
			if (array[count] > array[count + 1]) {
				if (verbose) {
					cout << "Value of: " << array[count] << " found at array location: "
					<< count << " is larger than the value: " << array[count + 1]
					<< " at array location: " << (count + 1) << endl;
				}
				//this series of assignments swaps the values using tempHold
				tempHold = array[count];
				array[count] = array[count + 1];
				array[count + 1] = tempHold;
				if (verbose) {
					cout << "These values were swapped such that the array location: "
					<< count << " now contains the smaller value: " << array[count]
					<< " and the array location: " << (count + 1) << " now contains: "
					<< array[count + 1] << endl;
				}
				//this confirms that at least one swap has occured during the current
				//cycle, informing the sort that another pass may be required to fully sort
				swapOccured = true;
			}	
		}
		if (verbose) {
			counter++;
			cout << "After pass #" << counter << " the array is: ";
			showArray(array, size);
      		cout << endl;
		}
	}
}

// <add code> Add your second sort algorithm in here
void insertionSort(int array[], int size, bool verbose=false) {
	//the usages of variables test and before at explained when they are 
	//initialized. However coutner keeps track of the # of sorts
	int before, test, count = 0;
	//this for loop cycles through the locations in the array until it hits
	//the sentinal value for the array. It starts at 1 bc the sorting occurs
	//behind the tested location
	for (int location = 1; location < size; location++) {
		//test holds the value for the current location being compaired to
		//previous values in the array
		test = array[location];
		//before begins one location before the tested array location
		before = location - 1;
		//this while loop is triggered if the value at the array location
		//marked before the test location is larger than the test location's value
		//and also ends once either sorting has been completed for this test OR
		//if the before value reaches a location that doesn't exist in the array
		while (before >= 0 && array[before] > test) {
			if (verbose) {
				cout << "Value of: " << array[before] << " found at array location: "
				<< before << " is larger than the value: " << array[test]
				<< " at array location: " << test << endl;
			}
			//this sets the array location that was just compaired to the test vlaue
			//to the new higher value. we dont need to worry about losing the value
			//at the test location bc that will be assigned once the while loop
			//completes it's task
			array[before + 1] = array [before];
			if (verbose) {
				cout << "These values were shuffled such that the value found at location: "
				<< before << " was set to the array location: " << (before + 1) 
				<< " which now contains the larger value: " << array[before + 1] << endl;
			}
			//this continues down the line of the array until it either hits the end
			//OR hits a point where the tested value is no longer smaller than the
			//compaired value
			before--;
		}
		//once the while loop completes, this sorts the tested value where the value
		//before it is smaller, and the value after it is larger
		array [before + 1] = test;
		if (verbose) {
			count++;
			cout << "The value: " << test << " was sorted to array location: "
			<< (before + 1) << " such that the value of " << array[before]
			<< " at location: " << before << " is smaller or equal to " << test
			<< " and the value of " << array[before +2] << " at location: "
			<< (before + 2) << " is greater than " << test 
			<< "\nAfter sort #" << count << " the array is: ";
			showArray(array, size);
      		cout << endl;
		}
	}
	//this signifies the end of the for loop checking the locations and should result
	//in a sorted array
}

/*
Test sorting algorithms on small array:

Selection sort start: smallArray is:  5 7 2 8 9 1
  prev min value: 5 at offset: 0; yet smaller value: 2 at offset: 2
  prev min value: 2 at offset: 2; yet smaller value: 1 at offset: 5
  swap prev min value: 5 with new min value: 1
After pass 0 the array is:  1 7 2 8 9 5

  prev min value: 7 at offset: 1; yet smaller value: 2 at offset: 2
  swap prev min value: 7 with new min value: 2
After pass 1 the array is:  1 2 7 8 9 5

  prev min value: 7 at offset: 2; yet smaller value: 5 at offset: 5
  swap prev min value: 7 with new min value: 5
After pass 2 the array is:  1 2 5 8 9 7

  prev min value: 8 at offset: 3; yet smaller value: 7 at offset: 5
  swap prev min value: 8 with new min value: 7
After pass 3 the array is:  1 2 5 7 9 8

  prev min value: 9 at offset: 4; yet smaller value: 8 at offset: 5
  swap prev min value: 9 with new min value: 8
After pass 4 the array is:  1 2 5 7 8 9

Selection sort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

Bubble sort start: smallArray is:  5 7 2 8 9 1
Value of: 7 found at array location: 1 is larger than the value: 2 at array location: 2
These values were swapped such that the array location: 1 now contains the smaller value: 2 and the array location: 2 now contains: 7
Value of: 9 found at array location: 4 is larger than the value: 1 at array location: 5
These values were swapped such that the array location: 4 now contains the smaller value: 1 and the array location: 5 now contains: 9
After pass #1 the array is:  5 2 7 8 1 9

Value of: 5 found at array location: 0 is larger than the value: 2 at array location: 1
These values were swapped such that the array location: 0 now contains the smaller value: 2 and the array location: 1 now contains: 5
Value of: 8 found at array location: 3 is larger than the value: 1 at array location: 4
These values were swapped such that the array location: 3 now contains the smaller value: 1 and the array location: 4 now contains: 8
After pass #2 the array is:  2 5 7 1 8 9

Value of: 7 found at array location: 2 is larger than the value: 1 at array location: 3
These values were swapped such that the array location: 2 now contains the smaller value: 1 and the array location: 3 now contains: 7
After pass #3 the array is:  2 5 1 7 8 9

Value of: 5 found at array location: 1 is larger than the value: 1 at array location: 2
These values were swapped such that the array location: 1 now contains the smaller value: 1 and the array location: 2 now contains: 5
After pass #4 the array is:  2 1 5 7 8 9

Value of: 2 found at array location: 0 is larger than the value: 1 at array location: 1
These values were swapped such that the array location: 0 now contains the smaller value: 1 and the array location: 1 now contains: 2
After pass #5 the array is:  1 2 5 7 8 9

After pass #6 the array is:  1 2 5 7 8 9

Bubble sort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

Insertion sort start: smallArray is:  5 7 2 8 9 1
The value: 7 was sorted to array location: 1 such that the value of 5 at location: 0 is smaller or equal to 7 and the value of 2 at location: 2 is greater than 7
After sort #1 the array is:  5 7 2 8 9 1

Value of: 7 found at array location: 1 is larger than the value: 2 at array location: 2
These values were shuffled such that the value found at location: 1 was set to the array location: 2 which now contains the larger value: 7
Value of: 5 found at array location: 0 is larger than the value: 7 at array location: 2
These values were shuffled such that the value found at location: 0 was set to the array location: 1 which now contains the larger value: 5
The value: 2 was sorted to array location: 0 such that the value of 0 at location: -1 is smaller or equal to 2 and the value of 5 at location: 1 is greater than 2
After sort #2 the array is:  2 5 7 8 9 1

The value: 8 was sorted to array location: 3 such that the value of 7 at location: 2 is smaller or equal to 8 and the value of 9 at location: 4 is greater than 8
After sort #3 the array is:  2 5 7 8 9 1

The value: 9 was sorted to array location: 4 such that the value of 8 at location: 3 is smaller or equal to 9 and the value of 1 at location: 5 is greater than 9
After sort #4 the array is:  2 5 7 8 9 1

Value of: 9 found at array location: 4 is larger than the value: 5 at array location: 1
These values were shuffled such that the value found at location: 4 was set to the array location: 5 which now contains the larger value: 9
Value of: 8 found at array location: 3 is larger than the value: 5 at array location: 1
These values were shuffled such that the value found at location: 3 was set to the array location: 4 which now contains the larger value: 8
Value of: 7 found at array location: 2 is larger than the value: 5 at array location: 1
These values were shuffled such that the value found at location: 2 was set to the array location: 3 which now contains the larger value: 7
Value of: 5 found at array location: 1 is larger than the value: 5 at array location: 1
These values were shuffled such that the value found at location: 1 was set to the array location: 2 which now contains the larger value: 5
Value of: 2 found at array location: 0 is larger than the value: 5 at array location: 1
These values were shuffled such that the value found at location: 0 was set to the array location: 1 which now contains the larger value: 2
The value: 1 was sorted to array location: 0 such that the value of 0 at location: -1 is smaller or equal to 1 and the value of 2 at location: 1 is greater than 1
After sort #5 the array is:  1 2 5 7 8 9

Insertion sort stop:  smallArray is:  1 2 5 7 8 9
verified: smallArray is sorted.

Selection sort on bigArray took: 13448.00 milliseconds.

Bubble sort on bigArray took: 44222.00 milliseconds.

Insertion sort on bigArray took: 8315.00 milliseconds.

Linear search  of bigArray took:    0.52 milliseconds.

Binary search  of bigArray took:    0.00 milliseconds.

Algorithm             1000      5000     10000     20000     30000     40000     50000
================   =======   =======   =======   =======   =======   =======   =======
selection sort        5.00    154.00    551.00   2101.00   4715.00   8637.00  13354.00
bubble sort          12.00    370.00   1639.00   6906.00  17503.00  28056.00  45251.00
insertion sort        4.00     80.00    315.00   1286.00   2981.00   4118.00   7558.00
linear search         0.01      0.05      0.10      0.21      0.31      0.42      0.52
binary search         0.00      0.00      0.00      0.00      0.00      0.00      0.00


--------------------------------
Process exited after 215 seconds with return value 0
Press any key to continue . . .
*/
